---
/**
 * Handles Open Graph, Twitter Card meta tags, and JSON-LD structured data
 */

/**
 * Security Note: We use set:html with JSON.stringify() for JSON-LD schemas.
 * This is safe because:
 * 1. JSON.stringify() automatically escapes dangerous characters (< > & " ')
 * 2. All data comes from controlled sources (MDX frontmatter we author, config files)
 * 3. No user input from forms or URL parameters is used
 * 4. JSON.stringify() converts < to \u003c, > to \u003e, preventing script injection
 */
/* eslint-disable astro/no-set-html-directive */
import { SITE, SOCIAL, PROFESSIONAL, SEO, BLOG } from "@/config/site-config";

interface Props {
	title: string;
	description: string;
	url: string;
	image?: string;
	type?: "website" | "article";
	datePublished?: string;
	dateModified?: string;
	tags?: string[];
	category?: string;
	readingTime?: string;
}

const {
	title,
	description,
	url,
	image,
	type = "website",
	datePublished,
	dateModified,
	tags,
	category,
	readingTime,
} = Astro.props;
const isArticle = type === "article";
const siteUrl = SITE.url;

// Open Graph image dimensions
const ogImageWidth = isArticle ? 1200 : 400;
const ogImageHeight = isArticle ? 630 : 400;
const ogImageType = "image/png";

// Format published date for Twitter label
const formattedDate = datePublished
	? new Date(datePublished).toLocaleDateString("en-US", {
			year: "numeric",
			month: "short",
			day: "numeric",
		})
	: undefined;

// Use centralized social profiles from site-config
const socialProfiles = [...SOCIAL.profiles];

// Extract reading time number for timeRequired (e.g., "3 min read" -> 3)
const readingTimeMinutes = readingTime ? parseInt(readingTime.match(/\d+/)?.[0] || "1") : undefined;

// Estimate word count based on reading time (200 words per minute)
const estimatedWordCount = readingTimeMinutes ? readingTimeMinutes * 200 : undefined;

// Shared author object for schemas
const authorObject = {
	"@type": "Person" as const,
	name: SITE.author,
	url: siteUrl,
	sameAs: socialProfiles,
};

// BlogPosting schema for articles
const blogPostingSchema = {
	"@context": "https://schema.org",
	"@type": "BlogPosting",
	headline: title,
	description: description,
	image: image,
	url: url,
	datePublished: datePublished,
	dateModified: dateModified || datePublished,
	author: authorObject,
	publisher: {
		"@type": "Person",
		name: SITE.author,
		url: siteUrl,
	},
	isPartOf: {
		"@type": "Blog",
		name: BLOG.title,
		url: `${siteUrl}/blog`,
	},
	keywords: tags?.join(", "),
	wordCount: estimatedWordCount,
	timeRequired: readingTimeMinutes ? `PT${readingTimeMinutes}M` : undefined,
	mainEntityOfPage: {
		"@type": "WebPage",
		"@id": url,
	},
	inLanguage: SEO.locale.replace("_", "-"),
};

// WebPage schema for non-article pages (more appropriate than WebSite per-page)
const webPageSchema = {
	"@context": "https://schema.org",
	"@type": "WebPage",
	name: title,
	description: description,
	url: url,
	image: image,
	isPartOf: {
		"@type": "WebSite",
		name: SITE.title,
		url: siteUrl,
	},
	author: authorObject,
	inLanguage: SEO.locale.replace("_", "-"),
};

// WebSite schema (emitted once, stable across all pages)
const webSiteSchema = {
	"@context": "https://schema.org",
	"@type": "WebSite",
	name: SITE.title,
	description: SITE.description,
	url: siteUrl,
	author: {
		"@type": "Person",
		name: SITE.author,
		url: siteUrl,
		jobTitle: PROFESSIONAL.jobTitle,
		description: SITE.description,
		sameAs: socialProfiles,
	},
	publisher: {
		"@type": "Person",
		name: SITE.author,
		url: siteUrl,
	},
	potentialAction: {
		"@type": "SearchAction",
		target: {
			"@type": "EntryPoint",
			urlTemplate: `${siteUrl}/search?q={search_term_string}`,
		},
		"query-input": "required name=search_term_string",
	},
	inLanguage: SEO.locale.replace("_", "-"),
};

// Person schema (for personal identity - primary schema for personal site)
const personSchema = {
	"@context": "https://schema.org",
	"@type": "Person",
	name: SITE.author,
	url: siteUrl,
	image: `${siteUrl}/pwa-512x512.png`,
	jobTitle: PROFESSIONAL.jobTitle,
	description: SITE.description,
	knowsAbout: [...PROFESSIONAL.skills],
	alumniOf: {
		"@type": "CollegeOrUniversity",
		name: PROFESSIONAL.almaMater,
	},
	sameAs: socialProfiles,
};

// BreadcrumbList schema for blog posts
const pathSegments = url
	.replace(siteUrl, "")
	.split("/")
	.filter((segment) => segment);

/**
 * Format breadcrumb name: remove date prefix and title-case
 */
function formatBreadcrumbName(segment: string): string {
	if (segment === "blog") return "Blog";
	// Remove date prefix (YYYY-MM-DD-) from blog post slugs
	const withoutDate = segment.replace(/^\d{4}-\d{2}-\d{2}-/, "");
	// Replace hyphens with spaces and title-case each word
	return withoutDate.replace(/-/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
}

const breadcrumbSchema =
	isArticle && pathSegments.length > 0
		? {
				"@context": "https://schema.org",
				"@type": "BreadcrumbList",
				itemListElement: [
					{
						"@type": "ListItem",
						position: 1,
						name: "Home",
						item: siteUrl,
					},
					...pathSegments.map((segment, index) => ({
						"@type": "ListItem",
						position: index + 2,
						name: formatBreadcrumbName(segment),
						item: `${siteUrl}/${pathSegments.slice(0, index + 1).join("/")}`,
					})),
				],
			}
		: null;
---

<!-- Open Graph / Facebook -->
<meta property="og:type" content={isArticle ? "article" : "website"} />
<meta property="og:url" content={url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
{image && <meta property="og:image" content={image} />}
{image && <meta property="og:image:width" content={ogImageWidth.toString()} />}
{image && <meta property="og:image:height" content={ogImageHeight.toString()} />}
{image && <meta property="og:image:type" content={ogImageType} />}
{image && <meta property="og:image:alt" content={`${title} - ${description}`} />}
<meta property="og:site_name" content={SITE.author} />
<meta property="og:locale" content={SEO.locale} />
{isArticle && datePublished && <meta property="article:published_time" content={datePublished} />}
{isArticle && dateModified && <meta property="article:modified_time" content={dateModified} />}
{isArticle && <meta property="article:author" content={siteUrl} />}
{isArticle && category && <meta property="article:section" content={category} />}
{isArticle && tags?.map((tag) => <meta property="article:tag" content={tag} />)}

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:url" content={url} />
<meta name="twitter:title" content={title} />
<meta name="twitter:description" content={description} />
{image && <meta name="twitter:image" content={image} />}
{image && <meta name="twitter:image:alt" content={`${title} - ${description}`} />}
<meta name="twitter:creator" content={`@${SOCIAL.twitter}`} />
<meta name="twitter:site" content={`@${SOCIAL.twitter}`} />
{isArticle && readingTime && <meta name="twitter:label1" content="Reading time" />}
{isArticle && readingTime && <meta name="twitter:data1" content={readingTime} />}
{isArticle && formattedDate && <meta name="twitter:label2" content="Published" />}
{isArticle && formattedDate && <meta name="twitter:data2" content={formattedDate} />}

<!-- JSON-LD: Page-specific schema (BlogPosting for articles, WebPage for other pages) -->
<script type="application/ld+json" set:html={JSON.stringify(isArticle ? blogPostingSchema : webPageSchema)} is:inline />

<!-- JSON-LD: WebSite schema (stable, same for every page) -->
<script type="application/ld+json" set:html={JSON.stringify(webSiteSchema)} is:inline />

<!-- JSON-LD: Person schema (primary identity for personal site) -->
<script type="application/ld+json" set:html={JSON.stringify(personSchema)} is:inline />

<!-- JSON-LD: BreadcrumbList (for articles only) -->
{breadcrumbSchema && <script type="application/ld+json" set:html={JSON.stringify(breadcrumbSchema)} is:inline />}
